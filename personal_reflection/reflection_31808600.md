First, I designed `datablock` to create a flexible way of encoding data into QR Code segments using various encoding modes (numeric, alphanumeric, binary, and ECI). Next, the core class, `QRDataBlock`, handles the construction of these segments through static methods like `make_numeric`, `make_alphanumeric`, and `make_bytes`, ensuring efficient text encoding. Then, I leveraged regular expressions to validate input, ensuring only valid characters are used for each mode. Additionally, I collaborated with teammate to complete `step_display_2`. I was responsible for determining whether the specified coordinates belong to `the finder, alignment, and timing patterns` based on the QR codes.

One problem was ensuring correctness when switching between different modes and handling ECI encoding complexities, because this required careful attention to each mode’s bit structure and ECI’s unique rules. Another problem was the need for precise bit-level encoding in QR codes, I had to manage bit manipulation to convert data segments into binary and align them with QR code standards.

I was pleased that code structure was solid and modular, facilitating future enhancements. If I were to revise this, I would improve error handling by breaking methods into smaller units and adding automated testing for edge cases.